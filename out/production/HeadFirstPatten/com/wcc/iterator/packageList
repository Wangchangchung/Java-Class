会见迭代器模式：
    关于迭代器，就是他依赖一个名为迭代器的接口。这个是一个可能的迭代器的接口：
    << interface >>
    Iterator
    hasNext()
    next()

    hasNext() 方法告诉我们，是否在这个聚合元素中还有更多的元素
    next() 方法返回这个聚合元素中的下一个对象
一旦有了这个接口，就可以为各种对象集合实现迭代器：
数组、列表、散列表.... 如果我们想为数组是吸纳迭代器，就是实现这个接口就行了。


定义迭代器模式：
    提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示

迭代器模式能够让我们游走于聚合内的每一个元素，而又不暴露其内部的表示。
把游走的任务放在迭代器上，而不是聚合上。这样简化了聚合的接口和实现，也让责任各得其所


问题：
1、我听说过“内部的”迭代器 和 “外部的”迭代器。这是什么？
我们在前面的例子中使用的什么迭代器？
    我们实现的是外部迭代器，也就是说，客户端通过调用next()取得下一个元素，而内部的迭代器
    则是由迭代器自己控制的，在这种情况下，因为是由迭代器自行在元素之间游走，所以你必须
    告诉迭代器在游走的过程中你应该做什么，也就是说，你必须将操作传入给迭代器，因为客户端
    无法控制遍历额过程，所以内部迭代器比外部迭代器更没有弹性，然而，某些人可能认为内部的迭代器比较容易使用，
    因为只需将操作告诉它，它就会帮你完成所有的事情。

2、对于散列表这样的集合，元素之间没有很明显的次序关系，我们该怎么办？
    迭代器意味着没有次序，只是取出所有的元素，并不表示取出元素的向后顺序就代表元素的大小
    ，对于迭代器来说，数据结构可以是有次序的，或者是没有次序的。甚至数据是可以重复的
    除非某个集合的文件有特别的说明，否则不可以对迭代器所取出的元素大小顺序做出假设。

OOP原则：

    类的每个责任都有改变的潜在区域，超过一个责任，意味着超过一个改变
    的区域。这个原则告诉我们，尽量让每一个类保持单一责任。

内聚：用来度量一个类或者模块紧密地达到单一目的或责任
     当一个模块或者一个类被设计成只支持一组相关的功能的时候
     我们说它具有高内聚，反之，当被设计成支持一组不相关的功能时，我们说它具有低内聚。

ArrayList、 Vector、LinkedList、Stack、和PriorityQueue。
这些类都实现了java.util.Collection接口，这个接口包含了很多有用的方法，可以操作一群对象
<< interface >>
add()
addAll()
clear()
containsAll()
iterator()
remove()
removeAll()
toArray()
size()

HashTable 对于迭代器的支持是间接地。
这个迭代器不是直接从HashTable取出，而是由HashTable中的value或keSet取出的

Collection 和Iterator的好处在于，每个Collection都知道如何创建自己的Iterator
。例如： ArrayList只要调用iterator()， 就可以返回一个具体的iterator
而你根本不需要知道或者关系到底使用了哪个具体的类，你只要使用啊的Iterator接口就行了

Java 5的迭代器和集合
Java 5包含一种新的形式的for语句，称为for/in,这个可以让你在一个集合或者一个数组红遍历
而且不用显示的创建迭代器


组合模式：
    组合模式让我们能用树形方式创建对象的结构，树里包含了组合以及个别的对象

    使用组合结构，我们能把相同的操做应用在组合和个别的对象上，换句话说，在大多数情况下
    我们可以忽略对象组合和个别对象之间的差别





