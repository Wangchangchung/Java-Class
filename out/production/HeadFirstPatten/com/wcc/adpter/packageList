适配器模式：
    将一个类的接口，转换成客户期望的另一个接口，
    适配器让原本接口不兼容的类可以合作无间。

    适配器实现了目标接口，并持有被适配者的实例

客户使用适配器的过程如下：
1、客户通过目标接口调用适配器的方法对适配器发出请求
2、适配器使用被适配者接口把请求转换成被适配者的一个
或多个调用接口
3、客户接收到调的结果，但是并未察觉这一切是适配器所做的转换。

一个适配器只能装饰一个类吗？

1、适配器模式的工作是将一个接口转换成另一个
    虽然大多数的适配器模式所采取的例子都是让一个适配器包装一个被适配者。
    但是我们知道这个世界其实复杂了很多，所以你可能遇到一些情况，需要让
    一个适配器包装多个被适配者
    这个涉及另一个模式，被称为外观模式。



### 适配器有对象适配器和类适配器

**对象适配器和类适配器的区别是：**

1、对象适配器是使用组合的方式将请求传送给被适配者

2、类适配器是继承了 Target 和 Apaptee

3、对象适配器使用的是组合，所以不仅可以适配某一个类，而且也可以适配该类中的
任何子类，所以相比 类适配器 更胜一筹，但是类适配器也是有一个优点: 不需要实现
重新实现整个被适配者，必要的时候，我们可以覆盖适配者的行为。

4、对象适配器更具有弹性，但是类适配器更具有效率。

Java 中真实适配器的使用：
     将枚举适配到迭代器
  旧世界的枚举器：
        早期的集合(Colloection)类型(例如： Vector、Stack、Hashtable)都实现
        了一个名为 elements() 的方法，该方法 返回一个Enumeration(举)
        这个Enumeration 接口可以逐一的走过此集合内的每一个元素，而无需要知道他们在集合内
        是如何被管理的。
        hasMoreElements()  //告知是否在集合中还有更多的元素
        nextElement() 取得集合中的下一个元素

  新世界的迭代器：
        Sun 更新的集合中使用了Iterator(迭代器)接口，这个接口和枚举接口很像
        都可以让你遍历此集合中的每一个元素，但是不同的是，迭代器中还提供对元素的集合进行修改的
        功能。

适配器与装饰者的区别：

1、适配器： 我们允许客户使用新的库和子集合，无需改变“任何”代码。由适配器负责做转换就可以，这个就是
适配器的市场。
2、装饰者也可以做到上面的行为，但是装饰者可以让“新行为”加入类中，而无需修改现有的代码
    我还是认为适配器只是一种装饰者的变体，我的意思是说，适配器就和我们一样，都是用来包装对象的。


-----------------------------------------------------------------------------------------------------


外观模式的定义：
    提供了一个统一的接口，用来访问子系统中的一群接口，，外观定义了一个高层接口，让子系统更容易使用

这个定义清除的告诉我们，外观的意图是：要提供给一个简单的接口，好让一个子系统更便于使用

OOP 的设计原则： 最少知识原则
最少知识原则 告诉我们要减少对象之间的交互，只留下几个密友
这个到底是什么意思？这是说,当你正在设计一个系统，不管是任何对象
你都要注意它所交互的类有哪些，并注意它和这些类是如何交互的。


要怎么样才能够避免交上太多的朋友呢？
我们么应该调用属于以下范围的方法：

1、该对象本身
2、被当做方法的参数而传递进来的对象
3、此方法所创建或实例化的任何对象
----------------------------- 注意，上面的这些方针告诉我们，如果某对象是调用其他的方法
的返回结果，不要调用该对象的方法。

4、对象的任何组件
----------------------- 把“组件”想象成是被实例变量所引用的任何对象，换句话说，把这想象成
是“有一个”关系

采用最少知识的原则有什么缺点？
 回答： 这个原则减少了对象之间的依赖，研究显示这个会减少软件的维护成本
 但是采用这个方法会导致跟多的“包装”类被限制造出来，以处理和其他组件的沟通，
 这个可能导致复杂度和开发时间增加，并降低运行时的性能。


外观设计模式与适配器：
    外观不只是简化了接口，也将客户从组件的子系统中解耦。
    外观和适配器可以包装许多类，但是外观的意图是简化接口，而适配器的意图
    是将接口转换成不同的接口

1、如果外观封装可子系统的类，那么需要底层功能的客户如何接触这些类
    外观只提供简化的接口，所以客户如果觉得有必要，，依然可以直接使用过子系统的类
    这是外观模式的一个很好的特征： 提供简化的接口的同时，依然将系统完整的功能暴露出来，
    以供需要的人使用。



要点：
1、当需要使用一个现在有的类而其接口不符合你的需要的时候，就使用适配器
2、当需要简化并统一一个很大的接口或者一群复杂的接口时，使用外观。
3、适配器改变接口以符合客户的期望。
4、外观将客户从一个复杂的子系统中解耦。
5、实现一个适配器可能需要一番功夫，视目标接口的大小与复杂度而定。
6、实现一个外观，需要将子系统组合进外观中，然后将工作委托给子系统执行
7、适配器模式有两种：对象适配器和类适配器。类适配器需要用到多重继承
8、你可以让一个子系统实现一个以上的外观。
9、适配器将一个对象包装起来以改变其接口
装饰者将一个对象包装起来以增加新的行为和责任，而外观将一群对象“包装”
起来以简化其接口。


