认识模板方法：
    模板方法定义了一个算法步骤，允许子类为一个或多个步骤提供实现

1、算法在超类中定义，很好额保护了算法
2、由于有超类的存在，所以，可以将代码最大的复用
3、算法只存在一个地方，方便修改
4、模板方法提供了框架，新的子类可以插入进来。
5、超类专注于算法本身，而子类提供完整的实现。


定义模板方法模式：
    在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中，模板
    方法使得子类可以在不改变算法结构的情况下，重新定义算法的某些步骤。

对模板方法进行挂钩
    钩子是一种悲剧声明在抽象了中的方法，但是只有空的或者默认的实现。
    钩子的存在，可以让子类有能力对方法的不同点进行挂钩，要不要挂钩、由子类自行决定。


问题：
1、当我们创建一个模板方法的时，怎么才能知道什么时候使用抽象方法
什么时候使用钩子？
    当你的子类"必须"提供算法中某个方法或步骤的实现时，就使用抽象方法
    如果算法的这个部分是可选的，就用钩子，如果算法的这个部分是可选的，就用钩子，如果是
    钩子的化，子类可以是吸纳这个钩子，但是并不强制这么做。

2、使用钩子的正真的目的是什么？
钩子的几种用用法：
1、钩子可以让子类实现算法中可选的部分，在钩子对于子类的实现并不重要的时候，子类可以对此钩子置之不理
2、让子类能够有机会对模板中某些即将发生的(或刚刚发生的)步骤做出反应，比方说，名为justReOrederList()
的钩子方法允许子类在内部列表重新组织后执行某些动作(列如：在屏幕上重新显示数据)
正如你看到的，钩子也可以让子类有能力为其抽象列做一些决定。

3、子类必须是实现抽象类中的所有方法吗？
    是的，具体的子类中的都必须实现每一个抽象的方法。

OOP设计原则：
1、好莱坞原则
别调用(打电话给)我们，我们会调用(打电话给)你
好莱坞原则可以给我们一种防止“依赖腐败”的方法。

当高层主件依赖底层组件，而底层组件又依赖高层组件，而高层组件又
依赖边侧组件，边侧组件又依赖底层组件时，依赖腐败就发生了。

在好莱坞原则下，我们允许低层组件将自己挂钩到系统上，但是高层组件
会决定什么时候和怎么样使用这些低层组件，换句话说，高层组件对待低层组件的方式是
“别调用我，我们会调用你”

问题：
好莱坞原则和依赖倒置杨泽之间的关系是什么？

依赖倒置原则教我们尽量避免使用具体类，而多使用抽象。
而好莱坞原则是用在创建框架或组件上的一种技巧，好让低层组件
能够被挂钩进计算中，而且又不会让高层组件依赖低层组件，

两者的目标都是在于解耦，但是依赖倒置原则更加注重如何在设计中避免依赖，
好莱坞原则教我们一个技巧，创建一个有弹性的设计，允许低层结构能够相互操作
而又防止其他类太过依赖他们。


Java API 中哪些使用了模板方法呢？
Array类中的sort() 模板方法：
     * for(int i = low; i < hight; ++i){
     *     ... compareTo()...
     *     ...swap()...
     * }
     *
     * sort方法控制算法，没有类可以改变这一点，sort() 依赖一个Comparable类提供
     * compareTo() 的实现。
     *
     * Arrays中的这个sort就是一个模板设计模式：
     *有时候荒野中的模式并非是像教科书中的例子一样那么的中规中矩
     * 为了符合当前额环境和实现的约束，他们总是要被适当的进行修改。
     *
     * Arrays中的sort方法是符合模板方法的精神的。再者，由于不需要继承数组就能够使用这个算法
     * 这样使得排序变得更有弹性，更有用。
     *
     * 还有哪些Java的API中使用的是模板方法的例子？
     * java.io的InputStream类又一个read()方法，是由子类实现的，
     * 而这个方法又被read(byte b[], int off, int len) 模板方法使用
     * 还有Swing Applet


JFrame 最基本的Swing容器，继承了一个paint() 方法，在默认的情况下。
paint() 是不做任何事情的，因为它是一个"钩子"！ 通过覆盖paint(), 你可以将自己的代码
插入到JFrame()的算法中，显示出你想要的画面。

Applet 是一个能够子啊网页上执行该的小程序，任何Applet都必须继承自Applet类，而Applet类中
提供了好些钩子。具体的Applet大量使用钩子来提供行为，因为这些行为是做为钩子是实现的，所以Applet
类就不用去是实现他们。


模板方法和策略的比较：

策略：
    定义好一个算法家族，并让这些算法可以互换，正因为每一个算法都被封装起来了，所以客户端
    可以轻易的使用不同的算法。

模板：
    定义一个算法大纲，而由我的子类定义其中某些步骤的内容，
    这么一来，我在算法中的个别步骤可以有不同的实现细节，但是算法的数据结构
    依然保持不变。


模板：
    类的使用效率比较的高：策略的效率稍微低一些， 和策略采用的委托模型比起来，没有那么的复杂

要点：
1、"模板方法"定义了算法的步骤，把这些步骤延迟到了子类中是实现
2、模本方法模式为我们提供了一种代码复用的重要技巧
3、模板方法的抽象类可以定义具体的方法，抽象方法和钩子
4、抽象方法由子类实现
5、钩子是一种方法，它在抽象中不做任何的事情，或者只做默认的事情，子类可以选择要不要去覆盖它
6、为了子类防止改变模板方法中的算法，可以将抽象类中的算法声明为final
7、真实世界中有很多模板方法的变体，你可能不能一眼就辨认出来，但是他的确是模板方法呀
8、策略模式和模板方法模式都封装算法，一个用组合，一个用继承。、
9、工厂方法是模板方法的一种特殊版本。
